\documentclass[twoside]{report}
\usepackage{perpage}
\MakePerPage{footnote}
%\usepackage[latin1]{inputenc}
% \usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
% \usepackage[cm]{fullpage}
\usepackage[left=0.15\paperwidth, right=0.15\paperwidth]{geometry}
% \usepackage[margin=1.15in]{geometry}
\usepackage[xetex]{graphicx}
% \usepackage[pdftex]{graphicx}
\usepackage{setspace}
\usepackage{pgfgantt}
\usepackage{comment} 
\usepackage{amsmath}
\frenchbsetup{StandardLists=true}
\usepackage{enumitem}
\usepackage{tikz-uml}
\usepackage{url}
\usepackage{rotating}
\usepackage{hyperref}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{fontspec}
\usepackage{adjustbox}

\sloppy
\hyphenpenalty 10000000
\definecolor{bargreen}{RGB}{133,193,132}
\definecolor{groupgreen}{RGB}{53,107,52}
\definecolor{darkgreen}{RGB}{35,68,35}
\definecolor{linkred}{RGB}{165,0,33}
\definecolor{comment}{gray}{0.5}

\definecolor{fvo-green}{HTML}{1DBF73}
\definecolor{fvo-gray}{HTML}{212529}

%{Typewriter/teletype family},
\lstdefinestyle{cpp} {
basicstyle=\footnotesize\ttfamily,
language=C++,
captionpos=b,
commentstyle=\color{comment},
deletekeywords={static_cast},
keywordstyle=\color{blue},
morekeywords={LQViewable, GLFWwindow},
numbers=left,
numbersep=10pt,
numberstyle=\tiny\color{comment},
}

\lstdefinestyle{py} {
basicstyle=\footnotesize\ttfamily,
language=Python,
captionpos=b,
commentstyle=\color{comment},
deletekeywords={static_cast},
keywordstyle=\color{blue},
morekeywords={async, await},
numbers=left,
numbersep=10pt,
numberstyle=\tiny\color{comment},
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE]{Valentin \textsc{Fontaine}, Paul \textsc{Bunel}, Esteban \textsc{Baron}, Valentin \textsc{Peron}, Julien \textsc{Lebaron}}
\fancyhead[RO]{\textsc{Punyduck} — Rapport de projet T.E.R.}
\fancyfoot[C]{\thepage}

\newfontfamily\Montserrat{Montserrat}

% \usepackage{calc}
% \setlength\leftmargin{.15*\paperwidth}
% \setlength\rightmargin{.15*\paperwidth}

% \pagestyle{plain}


% TODO : Refaire partie 2.1.1 et 2.1.2 (mieux expliciter framework + décrire ce que l'on fait pour créer une vue)
        % Faire la partie 3.1 = ?val?
        % Partie 5
        % Relecture des fautes

\begin{document}

%page de garde
\begin{titlepage}
\Montserrat
%logo de la fds, de l'UM et des infos
% \includegraphics[scale=0.5]{logoFDS.png}
% \hfill
% \includegraphics[scale=0.2]{logoInfo.jpg}
% \vspace{1cm}

\begin{center}
%au dessus du titre
\textsc{\Huge{Punyduck}}\\

\vspace*{0.3cm}
\rule{2cm}{0.1pt}\\
\vspace*{0.3cm}

\textsc{\LARGE{Une plateforme de distribution de projets\\ \vspace{0.1cm} en ligne}}
% \vspace{1cm}

%titre
% \textsc{\huge{\textbf{Punyduck}}}\\
\vspace{0.8cm}
\textsc{Réalisé par :}\\
\vspace{0.2cm}
\includegraphics[scale=0.35]{fvologo1.png}\\
\vspace{0.2cm}
\large{\textbf{\color{fvo-green}FVO\color{fvo-gray}STUDIO}}

\vspace{1cm}
\textsc{\Large{Rapport de projet T.E.R.}}\\
\vspace{0.2cm}
\textsc{\Large{Projet Informatique - HLIN405}} 
% \vspace{2cm}
% \includegraphics[scale=0.5]{logoPunyDuck.jpg}
% \vfill
\end{center}

%noms/prenoms + Encadrante
% \begin{minipage}[t]{8.5cm}
% 	\begin{flushleft}

\vspace{1.7cm}
\large{\textbf{Étudiants :}}
\begin{itemize}[label=]
    \setlength\itemsep{0em}
    \item \large{Valentin \textsc{Fontaine}}
    \hfill \large{Valentin \textsc{Peron}}
    \item \large{Paul \textsc{Bunel}} 
    \hfill \large{Julien \textsc{Lebaron}}
    \item \large{Esteban \textsc{Baron}}
\end{itemize}

\vspace{0.5cm}
\large{\textbf{Encadrante :}}
\large{M\textsuperscript{me} Anne-Elisabeth \textsc{Baert}}
\hfill
\large{\textbf{Année :} 2019-2020}

% 	\end{flushleft}
% \end{minipage}
% \hfill
%année universitaire
% \begin{minipage}[t]{8cm}
% 	\begin{flushright} 
% 		\large{\textbf{Année :} 2020}
% 	\end{flushright}
% \end{minipage}

%logo de la fds, de l'UM et des infos
\vspace{0.8cm}
\begin{center}
\includegraphics[scale=0.6]{logoFDS.png}
\end{center}

% \hfill
% \includegraphics[scale=0.2]{logoInfo.jpg}

\end{titlepage}

%Sommaire
% \renewcommand{\contentsname}{Sommaire}
\setcounter{page}{1}
\setcounter{tocdepth}{1}
\tableofcontents
% \large{\tableofcontents}
% \thispagestyle{empty}

%renommer les chapitres en parties
\renewcommand{\chaptername}{Partie}


%Introduction 1/2 pages
\chapter*{Introduction} %Partie présentation
\addcontentsline{toc}{chapter}{Introduction}
Dans le cadre du TER de notre deuxième année à la faculté des sciences de Montpellier nous avons proposé un projet s'intitulant PunyDuck. Le but de ce projet est la réalisation d'une plate-forme de distribution des projets des étudiants du département informatique.\\

Le groupe de développement est composé de cinq personnes, Valentin \textsc{FONTAINE}, Paul \bsc{BUNEL}, Valentin \bsc{PERON}, Julien \bsc{LEBARON} et Esteban \bsc{BARON}. Nous sommes encadré par Mme Anne-Elisabeth \bsc{BAERT}.

\section*{Motivation}

Le TER est un module qui apporte beaucoup aux étudiants en gestion de projet ainsi qu'en programmation. Seulement une fois terminés les projets ne sont pas valorisés et tombent dans l'oubli. Notre solution est de proposer une application permettant à chaque étudiants de déposer leurs projets pour les rendre visibles et téléchargeables par tous.

\section*{Approches}
Notre objectif final étant de produire une application fonctionnelle pouvant être utilisée par tous, nous avions besoin : d'une interface graphique décente, totalement opérationnelle et facilement modulable, ainsi que d'un système de communication efficace entre l'application et la base de données. Nous avons donc décidé de diviser le projet en trois partie : tout d'abord la conception d'un framework permettant la réalisation d'interfaces graphiques, puis la réalisation de l'interface graphique elle-même à partir de ce framework, et enfin la partie réseau permettant à l'application de communiquer avec un serveur distant. Ces trois parties communiquent ensembles part le biais d'une architecture logicielle Modèle-Vue-Contrôleur (MVC).\\
Notre appplication est téléchargeable par tous depuis le site web \url{ https://fvostudio.com/punyduck/}.

\section*{Cahier des charges}
Le but de Punyduck est de proposer aux étudiants en informatique une plateforme de distribution de leurs différents projets. Cette plateforme doit être une application téléchargeable sur un site internet, et connectée à un serveur pour permettre l'échange de projets entre différents clients. \\
Pour l'organisation du projet, nous l'avons tout d'abord divisé en plusieurs étapes : 
\begin{itemize}[label=$-$]
    \item Mise en place d’un serveur qui servira d’intermédiaire entre les utilisateurs et la base de données.
    \item Création d’un framework pour faciliter la réalisation de l’application.
    \item Conception de l’application graphique à l’aide du framework.
    \item Connexion entre l’application graphique et le serveur.
    \item Création d’une base de données pour stocker les comptes des utilisateurs et les
projets.
    \item Mise en service d’un site internet permettant le téléchargement de l’application.
\end{itemize}
Ensuite, une fois les différentes parties du projet dégagées, pour bien définir chacune d'entre elles nous avons décidé du cahier des charges suivant :
\begin{description}
%I 
    \item[Le serveur :] Le serveur devra fonctionner de manière asynchrone (nous définiront ce principe dans la partie \ref{asyncio}). Il pourra héberger de manière sécurisée les données des utilisateurs (nom, mots de passes, ...) et devra être capable de gérer la plupart des erreurs de réseau, comme les coupures de connexion lors d'un téléchargement.
%II
    \item[Le framework :] Le framework définira un ensemble de classes et de fonctions qui serviront de base à la structure d'une nouvelle application. Son utilisation doit être facile avec assez de fonctionnalités déjà disponibles pour pouvoir réduire les appels de fonctions bas niveau. De plus, il devra également permettre la plasticité des interfaces.
%III
    \item[L’application :] Notre application présentera une interface graphique permettant de naviguer facilement entre différents onglets, de communiquer avec le serveur, et de personnaliser un minimum l'apparence : mode clair / sombre, position de certains éléments de la fenêtre, couleur de l’arrière plan.
%IV
    \item[La base de données :] Elle stockera les données relatives aux comptes des utilisateurs ainsi que les projets. Les données confidentielles (mots de passe) seront cryptées.
%V
    \item[Le site :] Il sera constitué d'une unique page permettant de télécharger l'application. Il possèdera un design « responsive~ » et dynamique.
\end{description}

%Quelques définitions ici comme dans l'exemple de rapport ?

%Partie 2 Partie technologies utilisées 1/2 pages
\chapter{Technologies utilisées}
\section{Langages}
Pour la programmation de notre application, nous avons choisis assez naturellement d'utiliser le langage C/C++. En effet, c'est le langage que nous avons le plus étudié à l'université, avec lequel 3 des 5 membres du groupe avaient codé leur projet de Licence 1 CMI, et qui nous offrait un support puissant et efficace pour notre interface graphique. \\
De plus le C++ nous a permis de coder en orienté objet, ce qui était une nécessité pour la création de notre application. En effet, notre programme utilise énormément ce type de programmation : nous développeront ce point plus tard dans la partie \ref{conception} sur la conception de l'application . \\

Pour l'interface graphique, nous avons utilisé la bibliothèque OpenGL : une interface regroupant environ 250 fonctions différentes qui peuvent être utilisées pour afficher des scènes tridimensionnelles complexes à partir de simples primitives géométriques. Du fait de son ouverture, de sa souplesse d'utilisation et de sa disponibilité sur toutes les plates-formes, OpenGL est une des bibliothèque graphiques les plus utilisée par la majorité des applications scientifiques, industrielles ou artistiques 3D. \\
L'utilisation de cette bibliothèque (associée à GLFW pour la gestion des fenêtres) était donc un choix assez basique puisqu'elle est très répandue, mais nous avons dû apprendre à l'utiliser : celle-ci est beaucoup plus complexe que les librairies que nous avions utilisées auparavant, comme SFML ou PyGame, de par son bas niveau. \\

Pour gérer la partie réseau de notre application, nous n'avions pas besoin d'utiliser un langage puissant comme le C/C++, nous pouvions donc nous rabattre sur un langage moins performant mais plus facile d'accès.
De ce fait, nous nous sommes dirigés vers le langage python, qui est un langage très simple d'utilisation, pratique pour débuter dans le domaine complexe de la programmation que représente la programmation en réseau. De surcroît il est plutôt efficace pour gérer les entrées sorties, notamment pour la lecture et l'écriture dans des fichiers, qui est une notion centrale dans notre projet.\\
Cependant, le langage Python de base ne permet pas de faire de la programmation en réseau, nous avons donc du choisir une des nombreuses bibliothèques disponibles permettant de faire de la programmation réseau en Python. \label{asyncio} Après réflexion, nous avons opté pour le module « asyncio » pour deux raisons : premièrement, ce module offrait une interface de programmation en réseau de haut niveau donc plus simple d'utilisation, ce qui nous arrangeait particulièrement étant donné que nous sommes parfaitement novices dans ce domaine ; Deuxièmement, le gros point fort de ce module est le fait qu'il implémente une nouvelle manière de programmer~: la programmation asynchrone. La programmation asynchrone pour les entrées/sorties est une forme de programmation parallèle permettant d'exécuter d'autres parties d'un programme lorsque celui-ci est en attente d'une transmission de donnée, afin de grandement diminuer le temps d'exécution du programme. \\

\section{Outils} %outils utilisés pourquoi ce choix avantages ? postgresql
Pour réaliser notre projet nous avons utilisé des outils différents et spécifiques à chaque tâche. \\

Nous avons utilisé le système de gestion PostgreSQL\footnote{PSQL : \url{https://www.postgresql.org/}} pour gérer la base de données de notre serveur, ce système nous permettant d'utiliser des requêtes SQL en Python et ainsi de mettre en application les connaissances acquises cette année avec le module HLIN304. \\
Pour pouvoir exécuter des requêtes SQL depuis le Python, nous avons employé le module psycopg2\footnote{psycopg2 : \url{https://www.psycopg.org/}} \\

Pour la partie modélisation de l'application nous avons opté pour le Langage de Modélisation Unifié (UML) vu en cours, dans le module HLIN406. \\

Toutes les communications du groupe se sont faites sur le logiciel Discord\footnote{Discord : \url{https://discordapp.com/}}, un logiciel facilitant grandement les communications en groupes avec par exemple le partage d'écran, les groupes vocaux et textuels, le fait de pouvoir partager des morceaux de code directement dans le canal de discussion textuel etc.. \\

Pour ce qui est du partage et des sauvegardes du code, nous avons utilisé Git (un logiciel de gestion de versions décentralisé) via un serveur GitHub\footnote{GitHub : \url{https://github.com/}, notre projet : \url{https://github.com/valfvo/punyduck}} qui nous a permis de garder nos anciennes versions, de ne rien perdre en cours de route, et de pouvoir partager l'avancée du projet avec les autres étudiants du groupes et notre encadrante. \\

Pour ce qui est de l'éditeur de code utilisé, nous nous sommes tous penché sur Visual Studio Code\footnote{VSCode : \url{https://code.visualstudio.com/}} pour sa fiabilité et sa mise en page agréable. De plus, nous avons pu, grâce à ce logiciel, coder à plusieurs en même temps avec sa fonctionnalité de partage en temps réel. \\

Enfin, nous avons utilisé le langage \LaTeX{} via la plateforme Overleaf\footnote{Overleaf : \url{https://www.overleaf.com/}} pour rédiger ce rapport.

%Partie 3 Développement logiciel 5/10 pages
\chapter{Conception de Punyduck}
\label{conception}
\section{L'architecture Modèle-Vue-Contrôleur}

Nous avons commencé par séparer le projet en trois grandes parties avant d'entamer la conception :
\begin{itemize}[label=$-$, leftmargin=1.5cm]
    \setlength\itemsep{0em}
    \item Le framework pour structurer l'application
    \item L'application utilisant le framework
    \item La communication réseau entre l'application et le serveur.
\end{itemize}

Par la suite nous avons opté pour une architecture \textit{Modèle-Vue-Contrôleur} (ou simplement \textit{MVC}) pour lier les différentes composantes du projet. En effet ce type d'architecture est plutôt populaire dans le développement d'interfaces graphiques car il permet une structure robuste et flexible avec une composition en trois modules:
\begin{itemize}[label=$-$, leftmargin=1.5cm]
    \setlength\itemsep{0em}
    \item \textbf{Le modèle}, qui contient toutes les données et la logique pour manipuler ces dernières. Il représente une petite base de données et n'a pas à se préoccuper de savoir comment afficher ces données.
    \item \textbf{La vue}, qui contient la représentation graphique des données du modèle sans avoir besoin de les détenir. Elle est une sorte de schéma que l'on peut ressortir dès que l'on veut afficher une donnée.
    \item \textbf{Le contrôleur}, qui contient la logique pour interagir avec l'utilisateur et sert d'intermédiaire entre le modèle et la vue. Il constitue le << cerveau >> de l'application.
\end{itemize}

Dans une architecture \textit{MVC}, chaque module est indépendant et n'a qu'une fonction spécifique. Cela facilite énormément le développement car on peut se concentrer sur une seule tâche sans se soucier du reste. Pour implémenter le patron \textit{MVC} à notre application nous avons décidé de faire du framework le contrôleur et le modèle. Le framework sert également de base à la vue, qui est naturellement l'interface graphique. La partie réseau en Python sert à communiquer avec le serveur pour mettre à jour le modèle.

\section{Développement de Litequarks, le framework}
\subsection{Début de la conception}

L'écrasante majorité du développement de notre application a été consacré à la réalisation du framework, qui représente environ 75 \% du projet. La conception d'un tel framework a été particulièrement difficile. Effectivement, l'objectif est de créer un outil que nous allons nous-même utiliser pour faciliter la mise en place de l'interface graphique. Il ne doit donc pas seulement marcher à peu près, il doit marcher à tout les coups dans toute les situations, en plus d'être pratique et facile à prendre en main. La complexité de réalisation est à un tout autre niveau d'un simple exercice où l'on peut ne pas réussir, ici l'échec n'est pas une option.\\

La première étape fut logiquement la conception, qui précède l'implémentation. C'est l'étape la plus difficile et la plus délicate. En effet si la conception n'est pas bonne, c'est toute l'implémentation et l'utilisation du framework qui seront pénalisés. Pour être sûr d'avoir une conception correcte nous avons décidé de consacrer la moitié du temps qui nous a été donné pour la réalisation du projet à la conception du framework, à savoir un mois et demi sur un total de trois mois.\\

Avant même de parler d'interface graphique, nous avons tenté d'imaginer une structure adéquate et flexible qui sera facilement utilisable. Cependant << simple à utiliser >> ne rime pas avec << simple à concevoir >> car chacun a sa propre logique. Notre tentative nous a donc mené à l'élaboration des \verb!LQuark!, qui permettent la création de \textit{structures hiérarchisées hétérogènes}. Une très grosse partie du framework repose sur cette structure, et dont il tire son nom (Litequarks, ou le diminutif \verb!LQ!).\\

\subsection{Des LQuark à l'interface graphique}

Les \verb!LQuark! sont le coeur du framework. Ils sont extrêmement simples mais permettent la création de structures très organisées grâce à un système de hiérarchie. Chaque quark possède un parent et plusieurs enfants sans limite de nombre ou éventuellement aucun. Les enfants de mêmes parents ont également des liens vers l'enfant précédant et l'enfant suivant. Enfin chaque quark a la possibilité de rajouter ou supprimer des enfants. Cette structure est comparable à un arbre n-aire où chaque noeud a un lien vers 2 noeuds qui ont le même noeud parent.\\

Une fois la structure des quarks terminée, nous nous sommes attelés à l'apprentissage de la bibliothèque graphique que nous avons utilisé, OpenGL. La prise en main fut assez longue et complexe. Effectivement avec OpenGL nous ne pouvons dessiner que de simples primitives graphiques, comme des traits ou des triangles. Il faut par exemple 2 triangles pour dessiner un rectangle. Pour simplifier cette utilisation peu commode, nous avons créé 2 classes :

\begin{itemize}[label=$-$, leftmargin=1.5cm]
    \setlength\itemsep{0em}
    \item \verb!LQTexture!, qui représente les pixels d'un rectangle ou d'une image en mémoire. Elle encapsule également toutes les données nécessaire à OpenGL pour dessiner ces pixels à l'écran.
    \item \verb!LQSurface!, qui représente une texture dans un espace en 2D. Une surface possède donc des coordonnées \textit{x} et \textit{y}, ainsi que différentes méthodes pour déplacer ces coordonnées et redimensionner la texture sous-jacente à la surface.
\end{itemize}

La classe \verb!LQSurface! hérite de \verb!LQTexture! mais aussi de \verb!LQuark!. C'est donc un autre pivot du framework car elle regroupe la praticité des quarks et l'utilisation facilité d'OpenGL par les textures. En combinant ainsi ces classes nous obtenons une structure particulièrement intéressante car nous pouvons désormais dessiner une surface sur autre surface très simplement. En effet grâce aux quarks chaque surface a des enfants et chaque enfant peut avoir des coordonnées relatives à son parent.\\

Par exemple, si une surface parent est en \verb!(100, 100)! et qu'elle a un enfant dont les coordonnées sont \verb!(50, 50)!, l'enfant aura une position absolue de \verb!(150, 150)!. Pouvoir placer ainsi des surfaces relativement à leur parent rend le placement d'éléments graphiques extrêmement simple et intuitif.\\

Pour compléter les surfaces, nous avons également implémenté une autre classe, \verb!LQViewable!. Assez légère, cette classe permet pourtant de faciliter davantage la création d'interfaces graphiques grâce à deux mécanismes. Le premier est la possibilité de << cacher >> un \verb!LQViewable!, c'est-à-dire qu'il est présent dans la structure des composants visuels mais n'est pas dessiné. Cela s'avère très pratique notamment pour afficher un message pour l'utilisateur, comme << votre projet est bien envoyé >> ou encore << veillez remplir tout les champs >>. Le second mécanisme est la capacité d'un \verb!LQViewable! a être flexible. Un élément flexible est un élément qui se redimensionne de lui-même pour toujours contenir tout ses fils. Ainsi suivant si un enfant est ajouté ou supprimé, il va s'agrandir ou se rétrécir.\\

Vous retrouverez ci-dessous les diagrammes UML des différentes classes précédemment introduites.\\

% --------------------- LQViewable ---------------------
\begin{center}
\begin{tikzpicture}
\umlclass[fill=gray!5]{LQViewable}{
    -- m\_flex : bool\\ 
    -- m\_hidden : bool
}{
    %+ <<create>>LQViewable();\\
    + <<create>>LQViewable(LQNumber x, LQNumber y,
               LQNumber width, LQNumber height,\\
               GLint color=0x000000, const std::string iconPath="")\\
    %+ <<create>>LQViewable(LQNumber x, LQNumber y, bool flex=true)\\
    %+ hidden() : bool\\ 
    + hide() : void\\
    + unhide() : void\\
    %+ flexible() : bool\\ 
    + displayFlex() : void\\
    %+ displayBlock() : void\\
    + appendChild(LQViewable child) :  LQViewable\\ 
    + drawChildren() : void \\
    + resizeWidthCallback() : void\\
    \umlvirt{+ resizeHeightCallback() : void}
}
\umlclass[x=-3, y=-5, fill=gray!5]{LQSurface}{...}{...}
\umlclass[x=3, y=-5, fill=gray!5]{LQNumber}{...}{...}
\umlassoc[geometry=--, mult=5, align=center]{LQSurface}{LQNumber}
\umlinherit[geometry=-|]{LQViewable}{LQSurface}
\end{tikzpicture}
\end{center}

% --------------------- LQuark, LQTexture, LQSurface ---------------------
\begin{adjustbox}{pagecenter}
\begin{tikzpicture}
\umlclass[x=-1,y=-10, fill=gray!5]{LQSurface}{
    -- m\_VBO : GLuint\\
    -- m\_VAO : GLuint\\ 
    -- m\_FBO : GLuint\\
    -- m\_shader : LQShader\\ 
    -- m\_x : LQNumber\\
    -- m\_y : LQNumber\\ 
    -- m\_width : LQNumber\\ 
    -- m\_height : LQNumber\\ 
    %les trois du bas font tout planter peux importe où tu les mets
    %-- m\_clearColor : LQColor\\
    %\umlstatic{-- s\_vertices[54] : GLfloat}\\
    %\umlstatic{-- s\_default\_shader : LQShader}
    }{
    + blit(LQTexture texture, GLfloat x, GLfloat y, GLuint VAO) : void\\
    + fill(GLfloat r, GLfloat g, GLfloat b, GLfloat a=1.0f) : void\\
    + blit(const LQSurface surface) : void\\
    + fill(LQColor color) : void\\
    + move(GLfloat x, GLfloat y) : void\\
    + move(glm::vec2 distance) : void\\
    + moveX(GLfloat x) : void\\
    + moveY(GLfloat y) : void\\
    + moveTo(GLfloat x, GLfloat y) : void\\
    + moveTo(glm\::vec2 position) : void\\
    + moveToX(GLfloat x) : void\\
    + moveToY(GLfloat y) : void\\
    }

\umlclass[x=-5, fill=gray!5]{LQuark}{
    -- m\_parent : LQuark \\
    -- m\_prevSibling : LQuark \\
    -- m\_nextSibling : LQuark \\
    -- m\_firstChild : LQuark \\
    -- m\_lastChild : LQuark \\
    %-- m\_childrenCount : LQuark \\
    }{
    + <<create>>LQuark() \\
    + parent() : LQuark \\
    + firstChild() : LQuark \\
    + lastChild() : LQuark \\
    %+ nthChild(LQindex nth) : LQuark \\
    + prevSibling() : LQuark \\
    + nextSibling() : LQuark \\
    %+ nthSibling(LQindex nth) : LQuark \\
    %+ childrenCount() : LQsize \\
    %+ setNextSibling(LQuark nextSibling): void \\
    + appendChild(LQuark child) : LQuark \\
    %+ insertChild(LQindex index, LQuark child) : LQuark \\
    %+ insertChildBefore(LQuark newChild, LQuark child) : LQuark \\
    %+ insertChildAfter(LQuark newChild, LQuark child) : LQuark \\
    %+ detach() : LQuark \\
    + removeChild(LQuark child) : LQuark \\
    %+ removeFirstChild() : LQuark \\
    %+ removeLastChild() : LQuark \\
    %+ removeChildren(LQuark newParent) : LQuark \\
    %+ swapWith(LQuark quark) : LQuark \\
    %+ swapChildren(LQuark first, LQuark second) : LQuark \\
    %+ swapChildren(LQindex first, LQindex second) : LQuark}
}
\umlclass[x=4.5, fill=gray!5]{LQTexture}{
    -- m\_id : GLuint \\
    -- m\_texWidth : GLuint \\
    -- m\_texHeight : GLuint \\
    -- m\_format : GLuint \\
    -- m\_wrapS : GLuint \\
    -- m\_wrapT : GLuint \\
    -- m\_minFilter : GLuint \\
    -- m\_magFilter : GLuint}{
    + <<create>>LQTexture(string path, int width, int height) \\
    + <<create>>LQTexture(LQTexture other) \\
    + <<create>>LQTexture()\\
    -- genTexture(): GLuint \\
    -- resize(GLuint texWidth, GLuint texHeight):LQTexture\\
    + getId(): GLint \\
    + getWidth(): GLint \\
    + getHeight(): GLint \\
    \umlstatic{+ deleteTexture(LQTexture texture): void}
}

%lien entre bloc
\umlaggreg[mult=5, pos=0.8, angle1=40, angle2=50, loopsize=2cm]{LQuark}{LQuark}
\umlinherit[geometry=-|]{LQSurface}{LQuark}
\umlinherit[geometry=|-]{LQSurface}{LQTexture}
\end{tikzpicture}
\end{adjustbox}

\subsection{Les LQNumber, des nombres dépendants d'autres}

Une autre clé de voûte du framework sont les \verb!LQNumber!. Ils permettent grâce à un système de trois classes d'avoir des nombres qui dépendent d'autres. Un tel système est plutôt pratique pour les quarks, car nous pouvons désormais créer des éléments dont la taille dépend de ses parents ou de ses voisins. C'est avec les \verb!LQNumber! que nous avons implémenté le \textit{responsive design} de notre application, qui permet aux éléments graphiques de s'adapter à n'importe quelle taille de fenêtre. Vous pouvez retrouver en annexe \ref{Projets} et \ref{resp1} des visuels montrant ce système. Les trois classes le composant sont :

\begin{itemize}[label=$-$, leftmargin=1.5cm]
    \setlength\itemsep{0em}
    \item \verb!LQNumber!, qui est un nombre dépendant d'une expression. Il possède aussi une liste des nombres qui dépendent de lui. À chaque fois qu'un nombre est mis à jour, chaque nombre de sa liste est notifié et va alors recalculer sa nouvelle valeur en fonction de son expression.
    \item \verb!LQMathExpr!, qui est une suite de variables avec une constante. Une expression possède par ailleurs des méthodes arithmétiques pour additionner, soustraire, multiplier ou diviser un expresssion par une autre expression ou une constante.
    \item \verb!LQMathVar!, qui est simplement un \verb!LQNumber! couplé à un coefficient positif ou négatif.
\end{itemize}

Les diagrammes UML des \verb!LQNumber! sont présentés à la page suivante.

\subsection{Fin du framework}

Pour finaliser le framework nous avons créé plusieurs autres classes que nous avons utilisés pour composer l'interface graphique de notre application. Elles reposent toutes sur les \verb!LQViewable! : \verb!LQText! pour afficher du texte, \verb!LQTextArea! pour entrer du texte dans un champ, \verb!LQButton! pour créer des boutons cliquables, \verb!LQViewport! et \verb!LQDocument! pour mettre en place un système de barres de défilement et enfin \verb!LQDrop! pour pouvoir glisser-déposer un fichier ou dossier dans l'application.

Nous n'entrerons pas dans les détails de ces classes pour garder un rapport d'une longueur acceptable.

\newpage

% --------------------- LQNumber ---------------------
\begin{adjustbox}{pagecenter}
\begin{tikzpicture}
\umlclass[x=-2, fill=gray!5]{LQNumber}{
    -- m\_quark : LQuark\\
    %-- (*m\_invoke)(LQuark*) : void \\ Trouver comment représenter une fonction en attribut UML
    -- m\_value : float \\
    -- m\_kind : Kind\\
    -- m\_expr : LQMathExpr \\
    -- m\_refs : forward\_list<LQNumber*> \\
    \umlstatic{-- s\_old : float}
}{
    + Kind : enum class ({value,length,coords})\\
    + <<create>>LQNumber() \\
    + <<create>>LQNumber(float value) \\
    + <<create>><<create>>LQNumber(LQMathExpr expr) \\
    + <<create>>LQNumber(Kind kind) \\
    + <<create>>LQNumber(LQNumber other) \\
    + linkQuark(TQuark quark) : void \\
    + recalc() : void \\
    + removeRef(LQNumber ref) : void \\
    + i() : float \\
    + f() : float \\
    + float() : operator \\
    \umlstatic{+ old() : float}
    }
\umlclass[x=7, y=-11, fill=gray!5]{LQMathVar}{
    -- m\_number : LQNumber \\
    -- m\_coeff : float \\
    -- m\_next : LQMathVar
}{
    + <<create>>LQMathVar(LQNumber number, float coeff=1.0f)\\
    + setNext(LQMathVar next) : void \\
    + eval() : float \\
    + parentCoords(LQNumber number) : bool \\
    + compatible(LQNumber number) : bool
}
\umlclass[x=7, y=-2.5, fill=gray!5]{LQMathExpr}{
    -- addCompatible(LQMathVar first, float coeff=1.0f) : void\\
    -- m\_first : LQMathVar \\
    -- m\_last : LQMathVar \\
    -- m\_constant : float \\
}{
%    + <<create>>LQMathExpr()\\
    + <<create>>LQMathExpr(LQNumber number)\\
    + <<create>>LQMathExpr(LQMathExpr other)\\
    + eval() : float \\
    + reset() : void \\
    \umlvirt{+ operator=(float constant) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator=(LQMathExpr expr) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator+=(float constant) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator-=(float constant) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator*=(float coeff) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator/=(float coeff) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator+(float constant) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator+(LQMathExpr other) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator-(float constant) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator-(LQMathExpr other) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator*(float coeff) : LQMathExpr <<operator>>}\\
    \umlvirt{+ operator/(float coeff) : LQMathExpr <<operator>>}
    }
    
\umlclass[x=9, y=3, fill=gray!5]{LQuark}{...\\}{...\\}
%lien
\umlaggreg[mult=1, pos=0.5, angle1=40, angle2=60, loopsize=2cm]{LQMathVar}{LQMathVar}
\umlaggreg[mult=n, pos=0.8, angle1=40, angle2=50, loopsize=2cm]{LQNumber}{LQNumber}
\umlassoc[geometry=--, mult=2]{LQMathVar}{LQMathExpr}
\umlassoc[geometry=|-]{LQMathExpr}{LQNumber}
\umlassoc[geometry=-|]{LQMathVar}{LQNumber}
\umlassoc[geometry=-|]{LQuark}{LQNumber}
\end{tikzpicture}
\end{adjustbox}

\section{Création de l'application}

L'interface graphique a été créée en plusieurs temps. Dans un premier temps il a fallu trouver une représentation graphique validée par tous les membres du groupe. Pour cela, nous avons fait la liste des différentes pages qui seraient dans l'application :

\begin{itemize}[label=$-$, leftmargin=1.5cm]
    \setlength\itemsep{0em}
    \item \textbf{Connexion} : une page permettant de s'inscrire ou se connecter à son compte
    \item \textbf{Projets} : une page affichant tous les projets stockés sur le serveur distant. C'est sur cette page que nous pouvons rechercher et télécharger un projet en particulier.
    \item \textbf{Dépôt} : une page pour pouvoir déposer ses projets sur l'application.
\end{itemize}

Par la suite nous les avons dessinés sur papier une par une, pour que chaque membre du groupe ait une vision très précise de l'aspect visuel de l'application. Enfin, nous avons utilisé le framework pour créer et agencer les composants spéfiques au visuel que nous voulions obtenir. Chacune des pages représente une << Vue >> dans l'architecture MVC décrite précédemment.\\

Par exemple pour la page << Projets >>, Nous avons conçu (liste non-exhaustive) :
\begin{itemize}[label=$-$]
    \item Une liste de boutons permettant de choisir comment trier les projets ("mieux notés", "plus récents", "plus anciens", ...)\footnote{\label{note}Cette fonctionnalité n'est pas encore implémentée, c'est donc pour l'instant une simple image}
    \item Une barre de recherche pour limiter la liste des résultats. Ainsi la recherche "ab" donne la liste de tout les projets dont le nom contient "ab"
    \item Des boutons qui permettent d'afficher les projets sous forme de liste ou sous forme de grille avec les images des projets\textsuperscript{\ref{note}}
    \item Une liste où chaque ligne correspond à un projet avec son nom, son << tag >> qui est sa catégorie (jeu, algorithme, logiciel...) et son image
\end{itemize}

Pour composer nos << Vues >> encore plus rapidement, nous avons créé une classe \verb!LQTreeCreator!. Cette classe permet de mettre à jour deux variables \verb!parent! et \verb!prev! à chaque nouvel élément ajouté à l'arbre des quarks pour pouvoir faire référence au parent et à l'élément précédent lors de la création d'un nouvel élément. De plus, les méthodes \verb!sub()! et \verb!super()! permettent de passer du quark parent au quark enfant ou inversement. Voici un exemple d'utilisation typique du framework pour créer un composant visuel :\\

\begin{lstlisting}[style=cpp, label=exv]
LQViewable *parent, *prev;
createTree(*this, parent, prev)
.add<LQViewable>(parent->x(), parent->y(), parent->width(), parent->height()).sub()
    .add<LQViewable>(10_px, 10_px, 50_px, 50_px)
    .add<LQViewable>(0_px, 0_px, prev->width(), parent->height()).super()
.add<LQViewable>(25_px, 25_px, 100_px, 200_px);
\end{lstlisting}

\newpage

\section{Communication réseau et base de données}
\subsection{Réalisation d'un client et d'un serveur}
La partie réseau de notre application s'est faite à part : en effet, elle utilisait un langage différent du reste (le Python) et devait s'exécuter dans un thread secondaire. Cette partie a donc commencé par l'apprentissage de la programmation en réseau via le module asyncio de Python. Ce module étant relativement simple d'utilisation, cette partie n'a pas posé beaucoup de problèmes. \\
Une fois que les bases étaient maîtrisées, nous avons dû créer deux programmes communiquants : un client et un serveur. Le rôle du client était de transmettre les requêtes de l'application au serveur, qui lui devait les analyser, et envoyer une réponse adaptée au client, qui la transmettait à nouveau à l'application. Les requêtes que le serveur devait être capable de gérer étaient peu nombreuses : transfert de projet dans un sens ou dans l'autre (client vers serveur ou serveur vers client) avec ajout dans la base de données, inscription, connexion, et demande de données à la base de données. Ainsi, nous avons opté pour une solution extrêmement simple : pour chacune de ces cinq requêtes, nous associons un numéro (de 1 à 5), que nous insérons au début de la chaîne-requête au moment de sa création dans le C++. Une fois la chaîne envoyée au client python, celui-ci lit le premier octet (donc le numéro de la requête) et exécute la fonction associée. Dans le même temps, il envoie la chaîne au serveur qui fait exactement la même chose. Ainsi, chaque partie de notre système client-serveur sait ce qu'elle doit faire en fonction du besoin de l'application.

\subsection{Interface Python/C++}
Une fois le client et le serveur finis et leur fonctionnalités implémentées, nous devions faire communiquer le client avec l'application C++ afin qu'ils puissent se transmettre des informations. Pour cela, nous avons créé en C++ un module Python basique nommé « gateway » utilisant une classe \verb!ClientGateway!. Cette classe contient deux attributs : deux \verb!std::queue! de tableau de charactères, l'une stockant les requêtes à envoyer au serveur, l'autre stockant les réponses (\verb!m_requests! et \verb!m_responses!).\\
Ainsi le module possède deux fonctions : \verb!poll_request! qui retourne le premier élément de \verb!m_requests!, et \verb!transmit_response! qui remplit \verb!m_responses! avec la chaîne passée en paramètre. Le client peut donc communiquer avec l'application de la manière suivante : à chaque tour de boucle, il appelle \verb!poll_request! pour voir s'il a reçu une action à exécuter, puis en cas de réponse du serveur, il transmet les informations nécessaire grâce à \verb!transmit_response!. De la même manière, lorsque l'application veut communiquer avec le client, elle remplit \verb!m_requests! ou regarde le contenu de \verb!m_responses!.\\
Enfin, étant donné que l'application n'a pas accès directement à \verb!m_requests! et \verb!m_responses! puisque que le module s'exécute dans un second thread, nous déclarons une instance de \verb!ClientGateway! dans le contrôleur, puis nous exécutons dans le second thread la fonction de la classe qui lance le programme Python du client. Cette opération nous donne donc accès aux attributs de la \verb!ClientGateway! du second thread directement depuis le contrôleur, dans le premier thread.

\section{Fonctionnalités de l'interface}
Au lancement de l'application Punyduck, une page d'accueil s'affiche\footnote{\label{note2}Les visuels des différentes pages de l'application sont disponibles en annexe \ref{visuels}} pour se connecter ou s'inscrire, avec un identifiant et un mot de passe. Une fois connecté, l’interface principale s'affiche, nous amenant sur la page « Projets ». \\
L'interface graphique est composé de plusieurs fenêtres, chacune spécifique. Pour les deux fenêtres principales une barre de navigation s'affiche en haut, contenant des liens vers la page « Projet », où l'ensemble des projets mis en ligne seront affichés, et la page « Dépot » qui servira à déposer un projet. \\

L'interface des projets\textsuperscript{\ref{note2}} permet de naviguer à travers les différents projets mis en ligne sur la plateforme et de les rechercher par leur nom (via la barre de recherche). Pour télécharger un projet, cela se fait simplement via le bouton à droite du tag du projet.\\
La page dépot\textsuperscript{\ref{note2}}, elle, permet à ceux qui souhaitent déposer leur propre projet sur la plateforme de le faire : il suffit de cliquer sur l'onglet "dépôt", glisser et déposer votre dossier ou fichier dans la zone correspondante, lui attribuer un nom puis un tag et enfin l'envoyer en ayant bien remplis tout les champs demandés.

\newpage
\section{Statistiques} %nombres de classes/scripts/ lignes de code/ nombre de module
Nous allons maintenant regarder Punyduck d’un point de vue des statistiques :\\
Le code cumule plus de 5400 lignes de code, dont plus de 4000 concernant uniquement le framework. Ce framework est composé de 28 élément et, on le voit sur la figure \ref{stats}, il représente les trois quart du projet. Le serveur est composé de 441 lignes de code, le client Python 310, et l'interface graphique de l'application (définition des << Vues >>) 687. Il y a 12 classes utilisées dans ce projet sans compter celles du framework.\\
Le site web est composé d’un fichier html de 175 lignes de code, d’un fichier css de 702 lignes de code et 7 illustrations. \\
Nous avons également réalisé un module en python qui a aidé pour la réalisation de l'application, et plus précisément pour faire communiquer le Python avec le C++ .\\
Concernant le github, il y environ 140 commits en tout, les premiers datant du 19 janvier et les derniers du 10 mai.
\vspace{2cm}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{camenbertstatPNDK.JPG}
    \caption{Proportion des lignes de code par rapport au partie du projet}
    \label{stats}
\end{figure}

%Partie 4 
\chapter{Présentation d'algorithmes}

Nous allons vous présenter ici deux algorithmes que nous avons jugés intéressants : la fonction du contrôleur qui s'occupe de savoir, à chaque déplacement du curseur, sur quel élément (\verb!LQViewable!) de la fenêtre il se trouve, et la fonction du serveur qui reçoit les requêtes SQL et renvoie une réponse adaptée.
\section{Fonction de position du curseur}
La classe \verb!LQAppController! possède un attribut \verb!s_hover_focus! qui est un pointeur vers le dernier \verb!LQViewable! sur lequel s'est positionné le curseur (initialisé sur la fenêtre de l'application lors du lancement du programme).
La méthode \verb!cursor_position_callback! de cette classe est une callback appelée par le module GLFW à chaque déplacement du curseur. Elle prend en paramètre un pointeur vers un objet \verb!GLFWwindow! représentant la fenêtre de l'application, ainsi que les coordonnées absolues du curseur $m_x$ et $m_y$, en nombre réel. Cette méthode calcule sur quel \verb!LQViewable! s'est déplacé le curseur, puis positionne l'attribut \verb!s_hover_focus! du contrôleur sur ce viewable. \\
Étant donné qu'un \verb!LQViewable! peut être situé dans un autre élément, et que sa position est relative par rapport à celle de son parent, et non absolue, il nous a fallu trouver une méthode efficace pour retrouver le \verb!LQViewable! dans lequel se trouve le curseur. \\

Le fonctionnement de la fonction est donc le suivant\footnote{Tout le long de l'explication de l'algorithme, nous considèrerons les coordonnées en abscisse et en ordonnée comme une seule variable pour plus de simplicité, bien que dans notre programme elles soient séparées en deux variables $x$ et $y$.} : à chaque appel de la fonction, on sauvegarde dans des attributs de la classe \verb!LQAppController! les dernières positions absolues et relatives (par rapport à \verb!s_hover_focus!) du curseur. Ensuite, nous calculons le déplacement $\Delta$ de la souris :
\[\Delta = m - prevAbs, \text{ avec $prevAbs$ la dernière position absolue du curseur}\]
Ensuite, nous ajoutons ce déplacement $\Delta$ sur nos anciennes coordonnées relatives à \verb!s_hover_focus!, afin d'obtenir la nouvelle position relative du curseur par rapport au dernier \verb!LQViewable!. Grâce à cela, nous pouvons définir un booléen important :
\[outCurrent = (prevRel < 0) \vee (prevRel > dim)\]
avec $prevRel$ la position relative du curseur et $dim$ les dimension d'un \verb!LQViewable!, ici \verb!s_hover_focus!. \\
Ce booléen nous permet de savoir, selon un \verb!LQViewable!, si notre curseur se situe à l'intérieur de celui-ci ou à l'extérieur (en supposant avoir les bonnes coordonnées relatives).
Une fois que ceci est fait, il ne nous reste plus qu'à vérifier si notre curseur est toujours dans \verb!s_hover_focus! : si oui, alors nous parcourons tous ses fils récursivement pour savoir si l'on se trouve dans l'un d'eux ; si non, alors on remonte les parents de \verb!s_hover_focus! jusqu'à trouver celui dans lequel nous sommes, puis nous parcourons également tous ses fils récursivement afin de trouver l'élément le plus précis dans lequel se trouve le curseur. À chaque déplacement dans l'arbre des éléments, nous devons également ajouter ou retirer à $prevRel$ les coordonnées relatives du dernier \verb!LQViewable! que l'on a testées, afin que notre booléen $outCurrent$ soit bien calculé avec les bonnes données. \\
Cet algorithme est de complexité $O(n+m)$ dans le pire des cas, avec $n$ le nombre de \verb!LQViewable! dans l'arbre et $m$ le nombre de fils du \verb!LQViewable! dans lequel le curseur se trouve ; mais sa complexité « amortie » est de $O(p)$ avec $p$ le nombre de fils de \verb!s_hover_focus!. L'implémentation en C++ de cet algorithme est disponible en annexe \ref{cpc}

\newpage
\section{Fonction de gestion des requêtes SQL}
Quand le serveur reçoit une requête SQL de la part du client, il doit la traiter avant de l'envoyer à la base de données, puis traiter la réponse avant de la renvoyer au client. Tout ceci se fait dans une fonction, que nous allons décrire ici. \\
Tout d'abord, le but de cette fonction est le suivant : elle reçoit en paramètre une chaîne de caractères contenant une requête SQL, et elle envoie au client un \verb!bytearray! contenant, dans l'ordre :
\begin{enumerate}
    \item la chaîne "dataReceive"
    \item suivie du nom du modèle qui recevra les données (afin que le client sache qu'il a reçu des données et à quel modèle elles sont destinées) ;
    \item le nombre d'items reçus (par exemple, si le modèle à modifier est \verb!Project!, un item correspond à un projet) ;
    \item Le nombre total d'attributs de la base de données, ici toujours égal à 15 ;
    \item le nombre d'attributs différents reçus (zéro s'ils sont tous envoyés) suivi de leur id ;
    \item et enfin, les données binaires récupérées dans la base de données grâce à la requête SQL.
\end{enumerate}
Pour cela, on crée en amont de la fonction un dictionnaire en variable globale, qui associe à chaque nom d'attribut de la base de donnée un id :
\begin{lstlisting}[style=py, caption=serveur.py : dictionnaire idColonne, label=idc]
idColonnes = {
    "idProjet": 0,
    "valide": 2,
    "nom": 3,
    "tag": 4,
    "pDescr": 5,
    "pPathImage": 6,
    "pIdLog": 7,
    "idLog": 8,
    "login": 9,
    "password": 10,
    "email": 11,
    "admin": 12,
    "uPathImage": 13,
    "uDescr": 14
}
\end{lstlisting}

Ensuite, la première étape est de savoir si la requête est de type « \verb!SELECT * FROM ...!~» ou si elle demande des attributs précis de la base de données, par exemple «~\verb!SELECT idProjet, nom, tag, login FROM Projet, UserInfo WHERE idLog = pIdLog;!~». \\

Dans le premier cas, la fonction exécute la requête dans la base de données et reçoit un tableau de \verb!tuples! en retour, chaque \verb!tuple! correspondant à une ligne de la base de données. On parcours donc chaque élément de ce tableau bidimensionnel, et en fonction de sa position dans le \verb!tuple!, on agit différemment : en effet, on ajoute pas la même chose dans la chaîne finale en fonction de si on reçoit une chaîne de caractère, un entier ou un chemin vers une image. Une fois que tous les éléments sont ajoutés à la chaîne finale, il ne reste plus qu'à ajouter les données manquantes au début de la chaîne, comme décrit juste avant ("dataReceive", nom du modèle, nombre d'items, etc.). \\

Dans le deuxième cas, c'est plus complexe : avant d'envoyer la requête à la base de données, il faut remettre les attributs dans le même ordre que dans le dictionnaire \verb!idColonnes! (\ref{idc}) afin que le client puisse lire la réponse dans le bon ordre. \\
Pour cela, nous avons implenté en Python l'algorithme triFusion étudié en cours d'algorithmique HLIN301 et HLIN401. En effet, l'objectif est de reconstruire la requête SQL dans le bon ordre avant de l'envoyer à la base de données : nous isolons donc les attributs de la requête dans un tableau grâce à des expressions régulières :
\begin{lstlisting}[style=py, caption=serveur.py : expressions régulières, label=re]
    match = re.search(r'^SELECT (.*) FROM .*;', query)
    if match != None:
        # On remet les attributs dans l'ordre afin de les recevoir correctement, et que le
        # client les recoive dans l'ordre
        rows = match.group(1).split(', ')
\end{lstlisting}
puis on appelle notre fonction \verb!triFusion! sur le tableau d'attributs (la fonction est adaptée pour pouvoir trier le tableau de chaîne de caractère par rapport au dictionnaire \verb!idColonnes!). Le tableau d'attributs est donc dans le bon ordre après cette opération, nous n'avons plus qu'à reconstruire la requête à partir de ce tableau et à l'exécuter dans la base de données. \\
Une fois que ceci est fait, le reste est essentiellement la même chose que dans le premier cas. \\

Cette fonction s'exécute en temps $O(nm)$ avec $n$ le nombre d'items renvoyé par la base de données et $m$ le nombre d'attributs pour chaque item. Le code Python de cette fonction est disponible en annexe \ref{sql}

%.Partie 5 1/2 pages
\chapter{Gestion du Projet}
\section{Organisation et planification}
Durant le développement de Punyduck, dès son début, nous avons décidé d'avancer le projet après les repas du midi,
ou dès que l'occasion se présentait. Étant toujours ensemble la plupart du temps, c'était donc de manière quotidienne que se faisait l'avancée du projet. Quand le travail se faisait à distance via la plate-forme "Discord", nous faisions en sorte de garder toutes traces de ce qui avait été fait, et de ce qui restait à faire, ainsi que de bien penser à mettre le git à jour pour chaque membre du projet.\\

À chaque fin de mois, nous organisions une entrevue avec notre encadrante Mme Anne-Elisabeth \textsc{Baert} afin de faire le point sur l'avancée du projet et de connaître ses priorités. Cela nous a permis de ne pas dériver et d'arriver jusqu'à l'aboutissement du projet. \\

Le développement du projet à été découpé en trois parties (hors site web et rapport) qui sont : la partie réseau en Python (le serveur/client et la base de données PostgreSQL), la partie framework et l'interface de notre application. Le groupe à été séparé au départ en deux groupes : un pour la partie réseau et l'autre pour la partie framework. La dernière partie a réuni les deux groupes afin de produire la liaison Python/C++ et la mise en place de l'interface graphique grâce au framework. \\

Une fois l'ensemble de l'application finie et fonctionnelle, nous avons mis le serveur en ligne afin que l'on puisse lancer l'application de n'importe où. \\
Également, le site web se faisait en parallèle du projet par Valentin \textsc{Peron} durant cette phase.\\

\newpage
\section{Changements majeurs}
L'organisation initiale du projet s'est vue considérablement changée tout au long du projet. En premier lieu, nous avons dû gérer la programmation de l'application avec seulement 3 membres du groupes sur les 5. Les tâches ont donc été au départ répartie de la manière suivante : Valentin \textsc{Fontaine} s'occupait du framework, Esteban \textsc{Baron} des débuts de l'interface graphique utilisant le framework, et Paul \textsc{Bunel} de la partie réseau en Python. \\
Puis, une fois ces parties bien avancées, nous avons commencé à mettre en place l'architecture MVC de notre application. À partir de là, nous n'étions plus que deux à nous occuper du code de l'application : ainsi, Valentin \textsc{Fontaine}, aidé par Paul \textsc{Bunel}, se sont donc occupés de l'implémentation de l'architecture MVC, ainsi que de la majorité de l'interface graphique de l'application. \\
Le diagramme de Gantt final du projet est disponible à la figure \ref{Gantt}.

\newpage
\thispagestyle{empty}

\begin{figure}[t]
\begin{rotate}{270}
    \setganttlinklabel{s-s}{START-TO-START}
    \setganttlinklabel{f-s}{FINISH-TO-START}
    \setganttlinklabel{f-f}{FINISH-TO-FINISH}
    \begin{ganttchart}[
        hgrid,
        vgrid={*{6}{draw=none},{dotted}},
        vrule/.style={very thick, red},
        x unit=0.155cm,
        time slot format=isodate,
        time slot unit=day,
        calendar week text = {W\currentweek{}},
        bar height = 0.6,
        bar top shift = 0.2,
        bar label node/.append style={align=left,text width={width("-------------------------------")}}, %largeur de la légende
        progress label text = \relax
        link/.style={-latex, line width=1.5pt, linkred},
        ]{2020-01-25}{2020-05-10}
        \gantttitlecalendar{year, month=name, week} \\
        \ganttbar[bar/.append style={fill=groupgreen}, name=ATF]{Asyncio, transfert de fichier}{2020-01-25}{2020-02-24}\\
        \ganttbar[bar/.append style={fill=groupgreen}, name=SQL]{SQL et base de données}{2020-02-25}{2020-03-20}\\
        \ganttbar[bar/.append style={fill=groupgreen}]{Interface python/C++}{2020-03-18}{2020-04-01}\\
        \ganttbar[bar/.append style={fill=darkgreen!60}, name=CF]{Conception du framework}{2020-01-25}{2020-03-10}\\
        \ganttbar[bar/.append style={fill=darkgreen!60}, name=IF]{Implémentation du framework}{2020-03-11}{2020-04-11}\\
        \ganttbar[bar/.append style={fill=darkgreen!60}, name=UF]{Utilisation du framework}{2020-04-12}{2020-04-30}\\
        \ganttbar[bar/.append style={fill=darkgreen!60}]{Event et Callback}{2020-03-29}{2020-04-20}\\
        \ganttbar[bar/.append style={fill=darkgreen!60}]{Interface graphique}{2020-04-26}{2020-04-30}\\
        \ganttbar[bar/.append style={fill=bargreen}, name=SW]{Site Web}{2020-04-12}{2020-04-30}\\
        \ganttbar[bar/.append style={fill=bargreen!50}]{Rapport}{2020-04-15}{2020-05-10}
        \ganttvrule{2020-05-30}{2020-04-30}
        %link
        \ganttlink[link type=f-s]{ATF}{SQL}
        \ganttlink[link type=f-s]{CF}{IF}
        \ganttlink[link type=f-s]{IF}{UF}
        \ganttlink[link type=s-s]{UF}{SW}
    \end{ganttchart}
\end{rotate}

% \begin{figure}[b]
    % \setlength{\abovecaptionskip}{20pt plus 3pt minus 2pt}
    \centering
    \vspace*{21cm}
    \caption{Diagramme de Gantt du projet}
    \label{Gantt}
\end{figure}


%.Partie 6
\chapter{Bilan et Perspectives} %bilan et Conclusion, parler en onction du cahier des charges, les perspectives futur du projet et l'apport.
Le bilan pour la fin de projet est positive, bien que les objectifs du cahier des charges n'aient tous atteints par manque d'investissement de certains, nous avons quand même énormément appris grâce à ce projet, et avons produit une application dont nous sommes fiers même avec une équipe réduite pour le développement. \\
Grâce au développement de cette application, nous avons pu mettre en pratique les enseignements de plusieurs modules de licence : le module HLIN304 - Systèmes d'information et bases de données 1 pour les requêtes SQL, les modules de programmation impérative pour le développement en C++, le module HLIN406 - Modélisation et programmation par objet 1 pour la programmation orientée objet et le diagramme UML du framework, ainsi que les modules d'Algorithmique et de complexité pour l'étude de la complexité de nos principaux algorithmes. \\
De plus, nous avons réalisé cette application en partant du bas niveau pour le côté graphique, ce qui nous a permit de comprendre certaines mécaniques lors de la réalisation d'une telle application ; et nous avons pour la première fois fait de la programmation en réseau et en \textit{multithread}.

\section*{Perspectives}
Après la fin de ce projet, nous avons encore beaucoup de choses à améliorer pour l'application : plus de personnalisation de l'interface graphique, amélioration du framework, augmenter la sécurité du serveur, etc. Nous comptons donc continuer le développement du projet durant l'été qui suit, afin de produire une application plus aboutie, avec un maximum de fonctionnalités implentées sur les 3 plans framework / application / réseau.

%.Partie 7
\part*{Annexes}
\addcontentsline{toc}{part}{Annexes}

\begin{appendix}
\chapter{Visuels de l'application}
\label{visuels}
\begin{figure}[!h]
    \centering 
    \includegraphics[scale=0.3]{punyduck-img-1.png}
    \caption{Capture d'écran de l'interface de connexion}
    \label{Connexion}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[scale=0.3]{punyduck-img-2.png}
    \caption{Capture d'écran de la page projets}
    \label{Projets}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[scale=0.3]{punyduck-img-4.png}
    \caption{Capture d'écran de l'interface de dépôt}
    \label{Depot}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[scale=0.4]{punyduck-img-6.png}
    \caption{Exemple du \textit{responsive design} de la page << Projets >> }
    \label{resp1}
\end{figure}

\chapter{Principaux algorithmes}
\section{Fonction cursor\_position\_callback}
Callback appelée lors d'un déplacement du curseur, calculant le \verb!LQViewable! sur lequel le curseur se positionne.
\begin{lstlisting}[style=cpp, caption=LQAppController::cursor\_position\_callback, label=cpc]
void LQAppController::cursor_position_callback(GLFWwindow* window, double mx, double my) {
    float deltaX = mx - prevAbsX;
    float deltaY = my - prevAbsY;
    prevRelX += deltaX;
    prevRelY += deltaY;

    LQViewable* current = s_hover_focus;
    bool outCurrent = prevRelX < 0 || prevRelX > current->widthF() ||
                      prevRelY < 0 || prevRelY > current->heightF();

    // On cherche dans quel parent de s_hover_focus nous sommes
    while (outCurrent && current != s_window) {
        prevRelX += current->xF();
        prevRelY += current->yF();
        current = static_cast<LQViewable*>(current->parent());
        outCurrent = prevRelX < 0 || prevRelX > current->widthF() ||
                     prevRelY < 0 || prevRelY > current->heightF();
    }

    s_hover_focus = current;
    current = static_cast<LQViewable*>(current->firstChild());
    while (current) { // On recherche un fils correspondant a notre position
        outCurrent =
            prevRelX < current->xF() || prevRelY < current->yF() ||
            prevRelX > current->xF() + current->widthF() ||
            prevRelY > current->yF() + current->heightF();
        if (outCurrent) {
            current = static_cast<LQViewable*>(current->nextSibling());
        }
        else {
            s_hover_focus = current;
            prevRelX -= current->xF();
            prevRelY -= current->yF();
            current = static_cast<LQViewable*>(current->firstChild());
        }
    }

    prevAbsX = mx;
    prevAbsY = my;
}
\end{lstlisting}

\section{Fonction SQL}
Fonction exécutée par le serveur lorsque le client envoie une requête SQL.

\begin{lstlisting}[style=py, caption=serveur.py : SQL, label=sql]
def fusion(T1, T2, T):
    i1 = 0
    i2 = 0
    for i in range(len(T)):
        if i1 >= len(T1):
            T[i] = T2[i2]
            i2 += 1
        elif i2 >= len(T2):
            T[i] = T1[i1]
            i1 += 1
        elif idColonnes[T1[i1]] < idColonnes[T2[i2]]:
            T[i] = T1[i1]
            i1 += 1
        else:
            T[i] = T2[i2]
            i2 += 1

def triFusion(T): # Algorithme triFusion vu en cours HLIN301 et HLIN401
    if len(T) > 1:
        T1 = T[:int(len(T)/2)]
        triFusion(T1)
        T2 = T[int(len(T)/2):]
        triFusion(T2)
        
        fusion(T1, T2, T)

nAttributes = int(15).to_bytes(1, 'big')

async def SQL(writer, query):
    # query = model + requete SQL
    model = re.search(r'(.*)SELECT', query).group(1)
    query = re.search(r'(SELECT.*)', query).group(1)

    infos = b''
    nItems = 0

    if "*" in query: # Si la requete est du type "SELECT * FROM ..."
        cur.execute(query)
        datas = cur.fetchall()

        ordreIndice = int(0).to_bytes(4, 'big')
        if "Projet" in query:
            for data in datas:
                for row in range(len(data)): # On agit differemment en fonction du type de donnees
                    if row == 1 or row == 6:
                        img = Image.open(data[row].replace("\\\\", "\\"))
                        infos += img.width.to_bytes(4, 'big')
                        infos += img.height.to_bytes(4, 'big')
                        infos += GL_RGBA if img.mode == "RGBA" else GL_RGB
                        infos += len(img.tobytes()).to_bytes(4, 'big')
                        infos += img.tobytes()
                    elif row == 0 or row == 7 or row == 2:
                        infos += data[row].to_bytes(4, 'big')
                    else:
                        infos += data[row].encode() + b'\0'
                nItems += 1

        elif "UserInfo" in query:
            for data in datas:
                for row in range(len(data)): # On agit differemment en fonction du type de donnees
                    if row == 5:
                        img = Image.open(data[row])
                        infos += img.width.to_bytes(4, 'big')
                        infos += img.height.to_bytes(4, 'big')
                        infos += GL_RGBA if img.mode == "RGBA" else GL_RGB
                        infos += len(img.tobytes()).to_bytes(4, 'big')
                        infos += img.tobytes()
                    elif row == 0:
                        infos += data[row].to_bytes(4, 'big')
                    else:
                        infos += data[row].encode() + b'\0'
                nItems += 1
    
    else: # Si la requete est du style "SELECT ..., ... FROM ..."
        match = re.search(r'^SELECT (.*) FROM .*;', query)
        if match != None:
            # On remet les attributs dans l'ordre afin de les recevoir correctement, et que le
            # client les recoive dans l'ordre
            rows = match.group(1).split(', ')
            endQuery = re.search(r'(FROM.*)', query).group(1)
            triFusion(rows)
            query = "SELECT "
            for row in rows[:-1]:
                query += row + ", "
            query += rows[-1] + " " + endQuery

            # On sauvegarde l'ordre d'arrivee des attributs de la base de donnees
            ordreIndice = len(rows).to_bytes(4, 'big')
            for row in rows:
                ordreIndice += idColonnes[row].to_bytes(4, 'big')

            cur.execute(query)
            datas = cur.fetchall()

            for data in datas:
                for row in range(len(data)): # On agit differemment en fonction du type de donnees
                    if idColonnes[rows[row]] == 0 or idColonnes[rows[row]] == 2 or
                    idColonnes[rows[row]] == 7 or idColonnes[rows[row]] == 8:
                        infos += data[row].to_bytes(4, 'big')
                    elif idColonnes[rows[row]] == 6 or idColonnes[rows[row]] == 13:
                        fp = open(data[row], 'rb')
                        img = Image.open(fp)
                        infos += img.width.to_bytes(4, 'big')
                        infos += img.height.to_bytes(4, 'big')
                        infos += GL_RGBA if img.mode == "RGBA" else GL_RGB
                        infos += len(img.tobytes()).to_bytes(4, 'big')
                        infos += img.tobytes()
                    else:
                        infos += data[row].encode() + b'\0'
                nItems += 1

        # On construit la chaine a renvoyer au client
        infos = "dataReceive".encode() + b'\0' + model.encode() + b'\0' + \
                nItems.to_bytes(4, 'big') + nAttributes + ordreIndice + infos
        # str + \0 + str + \0 + 4 bytes + 1 byte + (4 bytes + 4 * nbIndice bytes) + n bytes
        
        await send_message(writer, infos)
\end{lstlisting}
\end{appendix}

\end{document}
